# -*- coding: utf-8 -*-
"""Assignment2-JayaraniEmekar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bcEk8rLXghp7xjFy0fxmtTJj4zp7Gi0r


**2. (b) The friendship paradox occurs when MND(G) is greater than (k). In terms of a social network, this means that, on average, each of your friends have more friends than you. For each node in the UC Irvine student network, determine the average degree of its neighbors and make a scatterplot with node degree on the x-axis and mean neighbor degree divided by node degree on the y-axis. Include a horizontal line separating points that display the friendship paradox and points that do not.**
"""

#imports Required
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from itertools import chain
from networkx.utils import cumulative_distribution, discrete_sequence
import math
import random
import scipy.io

"""This function is to calculate mean neighbor degree over the range"""

#This function is to calculate mean neighbor degree over the range

def is_friend_paradox(G): 
  plot_data_x = []
  plot_data_y = []
  #calculate average neighbor degree
  avg_neighbor_degree = nx.average_neighbor_degree(G) 
  mean_neighbour_degree  = 0
  k = 0
  n = len(G.nodes)
  for val in avg_neighbor_degree:
    mean_neighbour_degree += avg_neighbor_degree[val]
    k += G.degree(val)
    mean_neighbour_degree /= n
    k /= n
    plot_data_y.append(mean_neighbour_degree/k)
    plot_data_x.append(k)
  return plot_data_x, plot_data_y

"""
This function is used to plot the meanneighbor degree/degree on Y axis vs degree on X-axis
"""

# plot the meanneighbor degree/degree on Y axis vs degree on X-axis
def plot_graph_linear_log_axis(plot_data_x,plot_data_y,linearLog):
  # create plot on linear axis
  fig, ax = plt.subplots(figsize=(12, 6))
  ax.scatter(plot_data_x, plot_data_y)
  # add horozontal line
  ax.axhline(y=1, c="red", linewidth=2.4, zorder=0)
  ax.set_title('UC Irvine student network data - Linear Scale')
  ax.set_xlabel('Degree')
  ax.set_ylabel('Mean Neighbor Degree / Degree')
  if linearLog:
      plt.yscale('log')
      plt.xscale('log')
      ax.set_title('UC Irvine student network data - Log Scale')
  plt.show()

"""
Load UC Irvine student network data : https://toreopsahl.com/datasets/#online_social_network
"""

# Load UC Irvine student network data : https://toreopsahl.com/datasets/#online_social_network 
G = nx.read_edgelist("OClinks_w_chars.txt",data=[('weight', int)])
plot_data_x,plot_data_y = is_friend_paradox(G)

"""
Plotting UC Irvine student network data on linear axis
"""

# Plotting UC Irvine student network data on linear axis
plot_graph_linear_log_axis(plot_data_x,plot_data_y,False)

"""
Plotting UC Irvine student network data on Log axis
"""
# Plotting UC Irvine student network data on Log axis
plot_graph_linear_log_axis(plot_data_x,plot_data_y,True)

"""
**2. (c)	(5 pts) Does the UC Irvine student network display the friendship paradox? Why might this paradox not be so surprising? Given part (a), consider what must be true of G for this paradox to be absent.**

The paradox arises because numbers of friends people have are distributed in a way that follows a power law rather than an ordinary linear relationship. So most people have a few friends while a small number of people have lots of friends. It’s this second small group that causes the paradox. People with lots of friends are more likely to number among your friends in the first place. And when they do, they significantly raise the average number of friends that your friends have. That’s the reason that, on average, your friends have more friends than you do.

For example, consider a 10000-node network consisting of a complete graph with one edge removed. In such a network almost all of the nodes—9998 of them—have a degree larger than the average of their neighbours, but there are two outliers that substantially skew the distribution so that over the whole network nodes are still less popular than their neighbours on average. So, it is evident that friendship paradox would be present across almost all networks with common characteristics.

For friendship paradox to be absent in G, I can say that all nodes should have degree 0 (with no edges) but it can't be represented as regular graph or network. Second choice would be a graph with all nodes of degree 2 (basically a ring) .

**3.(a)Write a function configModel(degSeq) taking a degree sequence as input and returning a graph generated according to the configuration model as described in chapter 4.8 of Network Science.**

**Consider the set of graphs for which all vertices have degree 1 or 3 and n = 10^4 nodes. Let p1 be the probability that a node is of degree 1 and p3 = 1 − p1 be the probability that a node is of degree 3. Use configModel(degSeq) to make a figure showing the mean fractional size of the largest component for values of p1 from 0 to 1 in steps of 0.01. Estimate the value of p1 at which a phase transition occurs and the giant component disappears.**

This function is used to generate the graph with the given degree sequence using the configuration model
"""

#generate a graph with the given degree sequence using the configuration model
def configModel(degSeq):
  n = len(degSeq)
  G = nx.empty_graph(n, create_using=None)
  # If empty, return the null graph immediately.
  if n == 0:
    return G
  stublist = list(chain.from_iterable([n] * d for n, d in enumerate(degSeq)))
  # Choose a random balanced stublist, which gives a random pairing of nodes. 
  # In this implementation, we shuffle the list and then split it in half.
  n = len(stublist)
  half = n // 2
  random.shuffle(stublist)
  out_stublist, in_stublist = stublist[:half], stublist[half:]
  G.add_edges_from(zip(out_stublist, in_stublist))
    
  #To remove parallel edges:
  G = nx.Graph(G)
  
  #To remove self loops:
  G.remove_edges_from(nx.selfloop_edges(G))

  #get gaint component from graph
  giantSizes = max(nx.connected_components(G), key=len)
  giantC = G.subgraph(giantSizes)
  return giantC

"""Consider the set of graphs for which all vertices have degree 1 or 3 and n = 10^4 nodes. 

Let p1 be the probability that a node is of degree 1 and p3 = 1 − p1 be the probability that a node is of degree 3. 

Use configModel(degSeq) to make a figure showing the mean fractional size of the largest component for values of p1 from 0 to 1 in steps of 0.01.

Estimate the value of p1 at which a phase transition occurs and the giant component disappears
"""

n = 10000 # number of nodes n= 10^4
X =[]
Y =[]
for p in np.arange(0, 1, 0.01):
  # new dgree seq with diff probablity 
  degSeq = np.random.choice([1,3], p=[p,1-p], size=n)
  giantC = configModel(degSeq)  
  X.append(p)
  Y.append(giantC.number_of_nodes()/n)
plt.figure(figsize=(10, 6), dpi=80)
plt.scatter(X, Y)
plt.xlabel('Probablity (P)')
plt.ylabel('Num of Nodes in giant component(Ng)/ Num of nodes(N)')
plt.show()

"""**The value of P1 where the giant component disappers is approx 0.79 - 0.8**, at this point probablity of network is very large hence giant component transitions into connected regime comprised of all the nodes, i.e. complete graph. So, in this case giant component disappers at p=0.8

.

**3. (b)Write a function degPresRand(G) taking a graph G as input and returning a new network with a degree sequence identical to that of G as described in chapter 4.8 of Network Science. Write your function to perform at least  (m/2 log 10 ^7) rewirings as suggested here.**
"""

def degPresRand(G, rewires=1):
    n = 0
    swapcount = 0
    keys, degrees = zip(*G.degree())  # keys, degree
    cdf = nx.utils.cumulative_distribution(degrees)  # cdf of degree
    discrete_sequence = nx.utils.discrete_sequence
    while swapcount < rewires:
        # if random.random() < 0.5: continue # trick to avoid periodicities?
        # pick two random edges without creating edge list
        # choose source node indices from discrete distribution
        (ui, xi) = discrete_sequence(2, cdistribution=cdf, seed=random)
        if ui == xi:
            continue  # same source, skip
        u = keys[ui]  # convert index to label
        x = keys[xi]
        # choose target uniformly from neighbors
        v = random.choice(list(G[u]))
        y = random.choice(list(G[x]))
        if v == y:
            continue  # same target, skip
        if (x not in G[u]) and (y not in G[v]):  # don't create parallel edges
            G.add_edge(u, x)
            G.add_edge(v, y)
            G.remove_edge(u, v)
            G.remove_edge(x, y)
            swapcount += 1
        n += 1
    return G

"""For above function we can set any rewire value which can be directly passed to function

As asked in 3(b) it supports the rewires (m/2) * log 10^7

**3. (c)	Using both configModel(degSeq) and degPresRand(G), explore the degree and distance distributions of the undirected versions of Openflights airport network (2016) and the German highway system network (2002). What patterns do you notice? Do you observe any significant deviations in these networks from what we might expect given a graph with a similar degree sequence?**

This function is used to calculate the distances
"""

#This function is used to calculate the distances 
def distCounts(d):
  dists = {}
  for u in d:
    for v in d[u]:
      dists[d[u][v]] = dists.get(d[u][v], 0) + 1
  return dists

"""This function is used to plot network data with distance and count"""

# This function is used to plot network data with distance and count
def plotNetworkDataDistanceVsCount(G, networkDataName):

  print('Nodes', G.number_of_nodes(), 'Edges', G.number_of_edges())
  plt.figure(figsize=(10, 6), dpi=80)
  # Calculate distance 
  dists = dict(nx.all_pairs_shortest_path_length(G))
  dists = distCounts(dists)
  (X, Y) = zip(*[(key, dists[key]) for key in dists])
  plt.scatter(X, Y, c='b', label=networkDataName, alpha=0.5)
  
  # Calculate config model
  H = configModel([G.degree(v) for v in G.nodes()])
  configDists = dict(nx.all_pairs_shortest_path_length(H))
  configDists = distCounts(configDists)
  (X, Y) = zip(*[(key, configDists[key]) for key in configDists])
  plt.scatter(X, Y, c='g', label='Configuration Model', alpha=0.5)
  
  #rewires the (m/2) * log 10^7
  m= G.number_of_edges();
  rewires_num = int(((m/2) * math.log10(pow(10, 7)))) 
  # Calculate degree press randomization
  H = degPresRand(G,rewires_num)
  randDists = dict(nx.all_pairs_shortest_path_length(H))
  randDists = distCounts(randDists)
  (X, Y) = zip(*[(key, randDists[key]) for key in randDists])
  plt.scatter(X, Y, c='r', label='Degree Pres Rand', alpha=0.5)

  plt.title(networkDataName)
  plt.xlabel('Distance')
  plt.ylabel('Count')
  plt.legend(loc='upper right')
  plt.show()

"""Load German highway system network (2002) """

#Load German highway system network (2002) 
G = scipy.io.loadmat('autobahn.mat')
G = nx.from_numpy_matrix(G['auto1168'])
plotNetworkDataDistanceVsCount(G,'German highway system network (2002)')

"""Load Open fights airport network (2016) http://konect.cc/networks/openflights/"""

#Load Open fights airport network (2016)
G = nx.read_edgelist("out.openflights")
plotNetworkDataDistanceVsCount(G,'Open fights airport network (2016)')

""".

**Graph 1: German highway system network (2002):**

-> ⟨d⟩ seems like close for degree preserving randomization comparable to original data and hence, we can say that this is scale-free network.

-> ⟨d⟩ value for real-network , config model and degree preserving randomization is almost same (approx 15) and can not see much deviation on that part. Given the fact, we can state that both config model and degree-preserving randomization are not changing any degree distribution across the network. 

-> As ⟨d⟩ is comparable for all 3 networks, we can say that there are no hubs in the network.



**Graph 2: Open fights airport network (2016):**

-> ⟨d⟩ seems like some deviated for degree preserving randomization compared to original data and hence, we can say that this is not a scale-free network.

-> ⟨d⟩ value for config model and degree preserving randomization are approximately same or comparable and are bit left-skewed compared to original data. It may be safe to state that both config model and degree-preserving randomization changed the degree distribution across the network.

.
"""